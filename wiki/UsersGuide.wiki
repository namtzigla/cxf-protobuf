= User's Guide to cxf-protobuf =

<wiki:toc max_depth="3" />

== Introduction ==

cxf-protobuf is a simple integration of [http://cxf.apache.org/ Apache CXF], an open source services framework and [http://code.google.com/p/protobuf/ Google's Protocol Buffers]. The main features are

   * *server API for publishing a service that can process protocol buffer messages* 
   * *client API for sending messages to protocol buffer services using CXF's transport infrastructure*
   * *support for both RPC-style dispatching and single message handler style implementation on the server-side*
   * *integration with CXF's (Spring) configuration*
   * *description generation for protocol buffer services ?wsdl-style (adopted from the SOAP world)* 

== Examples ==

You can get the examples at the downloads page. You will need maven to build them. As an alternative, you can get the following jars manually and compile the examples against them with any tool or IDE you like:
   * CXF jars and dependencies
   * cxf-protobuf jar

=== Example 1: !AddressBook service ===

You can download this example at ...

All examples are built around the "address book" protocol buffer sample that you can find in [http://code.google.com/apis/protocolbuffers/docs/javatutorial.html Google's tutorial]: 


{{{
package tutorial;

option java_package = "com.example.tutorial";
option java_outer_classname = "AddressBookProtos";

message Person {
  required string name = 1;
  required int32 id = 2;
  optional string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    required string number = 1;
    optional PhoneType type = 2 [default = HOME];
  }

  repeated PhoneNumber phone = 4;
}

message AddressBook {
  repeated Person person = 1;
}
}}}

To make it a service, we need a service definition and a few extra messages:

{{{
service AddressBookService {
  rpc addPerson(Person) returns(AddressBookSize);
  rpc listPeople(NamePattern) returns(AddressBook);
}

message AddressBookSize {
  optional int32 size = 1;
}

message NamePattern {
  optional string pattern = 1;
}

}}}

So, we have the addPerson and listPeople operations: addPerson adds a new Person to the address book and returns the current size of the book; listPeople returns a subset of the address book that matches the name pattern passed.

Because protocol buffer messages are not self-describing, we need a "wrapper" message that the server expects to come in on the wire. The structure of the wrapper message is up to the developer of the service. In this case, for each operation the wrapper message has a field with the same name and with the type of the operation's parameter:

{{{
message AddressBookServiceMessage {
  optional Person addPerson = 1;
  optional NamePattern listPeople = 2;
}
}}}

I chose the name AddressBookServiceMessage to make it clear that AddressBookService always expects this type of message as the request. The client can decide which operation he or she wants to invoke by filling in the corresponding field in AddressBookServiceMessage (because of this, each field is declared optional). It is important to note that this is just a convention, you can choose other ways to structure your request message.

All we need to do now is put these definitions in a file (addressbook.proto) and generate the java stub for the service and messages:

{{{ protoc --java_out=. addressbook.proto }}}

This will generate the class `com.example.tutorial.AddressBookProtos`. This class contains the service interface and stub and all message types. The service interface (which is actually an abstract class) is called `com.example.tutorial.AddressBookProtos.AddressBookService`, you need to implement it like, for example:

{{{
public class AddressBookServiceImpl extends AddressBookService {
	Map<Integer, Person> records = new ConcurrentHashMap<Integer, Person>();

	public void listPeople(RpcController controller,
			NamePattern request, RpcCallback<AddressBook> done) {
		AddressBook.Builder addressbook = AddressBook
				.newBuilder();

		for (Person person : records.values()) {
			if (person.getName().indexOf(request.getPattern()) >= 0) {
				addressbook.addPerson(person);
			}
		}

		done.run(addressbook.build());
	}

	public void addPerson(RpcController controller,
			Person request, RpcCallback<AddressBookSize> done) {
		records.put(request.getId(), request);
		done.run(AddressBookSize.newBuilder().setSize(
				records.size()).build());
	}
}
}}}

To publish the AddressBookServiceImpl class as a service:

{{{
		ProtobufServerFactoryBean serverFactoryBean = new ProtobufServerFactoryBean();
		serverFactoryBean
				.setAddress("http://localhost:8888/AddressBookService");
		serverFactoryBean.setServiceBean(new AddressBookServiceImpl());
		serverFactoryBean.setMessageClass(AddressBookServiceMessage.class);
		serverFactoryBean.create();
}}}

=== Example 2: !AddressBook client ===

=== Example 3: !AddressBook service configured in Spring ===

=== Example 4: !AddressBook message handler service ===